{"summary": "poly(A) tail is a homopolymeric stretch of adenosines at the 3\u2032-end of the majority of eukaryotic mRNAs. the poly(A) tail is generated directly after transcription by the nontemplated addition of adenosines to the mRNA 3\u2032-end. the initial length of poly(A) tails generated by this process has been estimated to be around 250 nt in vitro. poly(A) tail length has been shown to correlate with translation efficiency during embryonic development. recent studies using C. elegans have proposed shorter poly(A) tails are more actively translated. longer tails are refractory to translation. long and short poly(A) tails can only indirectly identify the transcript linked to the poly(A) by alignment of short sequences representing the RNA 3\u2032-ends. tailfindr uses raw data without prior alignment as input. current base-callers do not perform well on long homopolymer RNA and DNA stretches, resulting in the length of poly(A) tails not being accurately reported. long stretches of monotonous low-variance raw signal corresponding to poly(A) tails can be observed at the beginning of most reads. the motor protein (red) is attached to the native RNA molecule (yellow) at the 3\u2032-end by a double-stranded adapter (light red) with oligo-T overhang. tailfindr algorithm for RNA sequencing data leads to signal tracks shown in B and ultimately poly(A) estimation. vertical density plots of poly(A) length estimation from tailfindr (light green) and Nanopolish (turquoise) on in vitro transcribed eGFP-RNA with known poly(A) tail length. barcodes that define molecules with specific poly(A) length are located at the 5\u2032-end of the eGFP RNA, only reads that cover the full RNA molecule from 5\u2032-end to 3\u2032-end were considered for the analysis. the estimated poly(A) tail lengths for each length group overall match the expected poly(A) tail length. the poly(A) estimation suffers from significant variation. the length of most barcoded molecules can be successfully estimated by the use of tailfindr on ONT RNA sequencing. cDNA sequencing approaches that retain the full-length poly(A) tail would enable studies where material is scarce as well as increase statistical power of poly(A) tail estimates. cDNA sequencing approaches that retain the full-length poly(A) tail would enable studies where material is scarce as well as increase statistical power of poly(A) tail estimates. tailfindr algorithm provides user with a tabular output of tail length measurements. eGFP coding sequence with known poly(A)/(T) length. eGFP coding sequence with known poly(A) length. nt: 97 for poly(A) and 110 for poly(T); 150 nt: 148 for poly(T) and 155 for poly(T). a small subpopulation of reads with shorter estimated tails could be observed. tailfindr is compatible with flip-flop model base-calling. flip-flop model base-calling detects more nucleotide translocations over poly(A) stretches when compared to standard model base-calling. flip-flop model base-calling detects more detected moves over poly(A)/(T) tail sections compared to standard model base-calling. however, the number of moves still underestimates existing poly(A)/(T) lengths. tailfindr operates on standard and flip-flop model base-calling. tailfindr estimates poly(A) tail length from base-called ONT native RNA sequencing Oxford nanopore Technologies (ONT) sequencing allows for sequencing of full-length native RNA molecules. long stretches of monotonous low-variance raw signal corresponding to poly(A) tails can be observed at the beginning of most reads. however, base-calling relies on fluctuations of the raw signal. these low-variance sections are poorly decoded into the correct nucleobase sequence. vertical density plots of poly(A) length estimation on in vitro transcribed eGFP-RNA with known poly(A) tail length. poly(A) estimates exceeding 300 nt were set to 300 prior to plotting. tailfindr provides the user with a tabular output containing the unique read-ID, the estimated poly(A) tail length and all factors extracted from the raw data that are needed to calculate the poly(A) tail estimate. barcodes that define molecules with specific poly(A) length are located at the 5\u2032-end of the eGFP RNA, only reads that cover the full RNA molecule from 5\u2032-end to 3\u2032-end were considered for the analysis. the estimated poly(A) tail lengths for each length group overall match the expected poly(A) tail length. the poly(A) estimation suffers from significant variation. the length of most barcoded molecules can be successfully estimated by the use of tailfindr on ONT RNA sequencing. both tools matched well in their estimated poly(A) tail lengths. cDNA sequencing approaches that retain the full-length poly(A) tail would enable studies where material is scarce as well as increase statistical power of poly(A) tail estimates. cDNA sequencing approaches result in double-stranded DNA, both poly(A) as well as poly(T) stretches are present in ONT sequencing reads. horizontal black lines demarcate expected poly(A) length for individual barcodes. vertical density plot of poly(A)/(T) length estimates on DNA sequences (gray) and poly(A) length estimates on RNA (light green) running algorithm provides user with tabular output of tail length measurements. poly(A)/(T) tail lengths larger than 10 nt could be observed. a small subpopulation of reads with shorter estimated tails could be observed. tailfindr is compatible with flip-flop model base-calling. flip-flop model base-calling detects more nucleotide translocations over poly(A) stretches when compared to standard model base-calling. however, the number of moves still underestimates existing poly(A)/(T) lengths. tailfindr used tailfindr to compare poly(A) and poly(T) tail measurements. poly(A) tail estimation for standard and flip-flop model base-calling. PCR-amplified eGFP coding sequence with different poly(A) tail lengths were base-called either with standard (x-axis) or flip-flop models (y-axis) transcriptome-wide analysis of poly(A) tail lengths has only recently emerged. the advent of native RNA sequencing technology allows direct sequencing of full-length mRNA molecules, which intrinsically contain their full poly(A) tail. however, even the most recent updates in base-calling tools do not perform well over long homopolymeric sequence stretches. tailfindr correctly estimates poly(A) tail lengths of in vitro transcribed RNA over a wide range of lengths. the final calculated poly(A) tail lengths differ slightly (Supplemental Fig. S2C,D) tailfindr estimates short poly(A) stretches slightly longer than Nanopolish. short-read sequencing approaches promise poly(A) measurements with just a few bases of deviation due to cyclic incorporation of nucleotides and integration of the fluorescence signal of multiple molecules toward one single base-call. the raw signal for ONT sequencing does not change over a homopolymeric region, making single-event detection almost impossible. long-read sequencing is intrinsically a single-molecule technique. long-read sequencing allows direct assignment of transcript isoforms to single molecules without bioinformatics post-processing. tailfindr is the first tool to show that poly(A) tails can be measured in ONT DNA sequencing. cDNA sequencing has the advantage to yield approximately 10 more data per library preparation compared to native RNA sequencing. future cDNA applications using Unique Molecular Identifiers (UMI) will make it possible to acquire multiple poly(A) tail measurements from each molecule. this would increase the fidelity of isoform-specific poly(A) tail measurements from each molecule. the resulting PCR products were digested with FastDigest Bfo1 (ThermoFisher, #FD2184) for 2 h and purified by Phenol\u2013chloroform extraction. an amount of 100\u2013300 ng of purified DNA was used for RNA in vitro transcription by the SP6 mMessage mMachine kit. proprietary sequencing adapter was ligated using T4 DNA ligase (NEB, #M0202M) and loaded onto ONT Sequencing Flow Cells (FLO-MIN106 R9.4.1) purified libraries were sequenced on flow cells (FLO-MIN106 R9.4.1) for 24 h using MinKNOW 2 software. alignments with a normalized alignment score below 0.6 were discarded as unspecific. barcoded eGFP RNA reads with known poly(A) length were demultiplexed by locating the first 29 bases of eGFP sequence. alignments were performed using local alignments with Biostrings. alignments with a normalized alignment score below 0.6 were discarded as unspecific. RNA reads with known poly(A) length were screened for the presence of the eGFP end sequence. tailfindr RNA poly(A) length estimation algorithm is extracted from the FAST5 files and z-normalized. the raw signal is smoothened by a moving average filter (window size 400 samples; stride 1) to produce two smoothened signals. the expected signal of the ONT adapter consists of one segment above and one segment below 0.3 in the smoothened signal. a read is considered poly(T)-containing if the normalized alignment score of front primer sequence is greater than that of the front primer sequence, and above the threshold of 0.6. a read is considered poly(A)-containing if the normalized alignment score of front primer sequence is greater than that of the front primer sequence. the alignment of end primer is considered the approximate start of the poly(A) or poly(T) stretch. the raw data is z-normalized and converted to absolute values. calculations to identify precise borders of poly(A)/(T) stretches are restricted to 3000 raw samples downstream from the rough start site. the difference of the precise boundaries define the raw length of poly(A)/(T) stretches in sample points. for flip-flop model base-calling, the raw signal is likely over-segmented resulting in too many nucleotide translocations. the average translocation rate is defined as the arithmetic mean of sample points per detected move after discarding the 5% highest outliers. an amount of 100\u2013300 ng of purified DNA was used for RNA in vitro transcription by the SP6 mMessage mMachine kit. the resulting RNA was purified using Zymo RNA Clean & Concentrator-5 columns (Zymo Research, #R1013). DNA sequencing was performed using the DNA Ligation Kits SQK-LSK108 and SQK-LSK109 on poly(A)-containing PCR products. 500 ng of pooled barcoded PCR products were end-prepped using the NEBNext Ultra II dA tailing module. purified libraries were sequenced on flow cells (FLO-MIN106 R9.4.1) for 24 h using MinKNOW 2. the barcode was assigned by aligning the expected barcode sequences against the extracted read sequence preceding the eGFP alignment. a read was considered a poly(A)-containing read if the normalized alignment score of eGFP was greater than the forward eGFP sequence. RNA reads with known poly(A) length were screened for the presence of the eGFP end sequence by querying the original FASTA string against the reverse-complement of the reverse eGFP end sequence. if not otherwise mentioned, alignments with a normalized alignment score below 0.6 were discarded as unspecific. the expected signal of the ONT adapter consists of one segment above and one segment below 0.3 in the smoothened signal. the next segment in which the smoothened signal is above 0.3 is considered the poly(A) region. the threshold was chosen as the expected normalized signal for regions of homopolymer A on average is 0.89. tailfindr DNA poly(A)/(T) estimation algorithm Unlike RNA, DNA is double-stranded. a read is considered poly(T)-containing if the normalized alignment score of front primer sequence is greater than that of the front primer sequence. a read is considered poly(A)-containing if the normalized alignment score of front primer sequence is greater than that of the front primer sequence. mean signal is generated by applying a sliding window (window size 10; stride 10) to the processed raw signal. the precise start of the respective tail is considered to be the first location after the rough start site where the calculated slope is between 0.2 and 0.2. the mean signal is between 0 and 0.3 for poly(T) reads and 0 to 0.6 for poly(A) reads. the average translocation rate is defined as the arithmetic mean of sample points per detected move. the average translocation rate is defined as the arithmetic mean of sample points per detected move after discarding the 5% highest outliers."}