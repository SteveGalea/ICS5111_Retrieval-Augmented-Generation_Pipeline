{"summary": "fast single-instruction-Multiple-Data Smith-Waterman is a key component of fast heuristic read mapping and variation detection tools for next-generation sequencing data. the fast Smith-Waterman-Gotoh algorithm (SW) [1,2] is the most influential algorithm for aligning a pair of sequences. striped SW is the fastest intra-sequence parallelized SIMD implementation running on x86 processors with the Streaming SIMD Extensions 2 instruction set. striped SW is tens of times faster than a standard SW implementation, but only a few aligners have used this more advanced algorithm. striped SW has been published for six years but is still in lack of a fast, versatile and standalone library. results and discussion Implementation The SSW library extends the Striped SW and SWPS3\u2019s SIMD implementations to provide the mapping location and detailed alignment information (traceback), without performance penalty. the tool is a demonstration of the API usage and a practical tool for accurate whole viral or bacterial genome alignment. it is sufficiently fast and memory-efficient for alignment to very large reference genome sequences, e.g. the human genome. a test data set is also provided there. our SSW algorithm is the fastest or equally fast to SSEARCH across the entire protein sequence length range we tested. 5 query proteins were searched against the whole Uni-Prot database and one quarter of the TrEMBL database. running time is shown on the y-axis for SSW without (blue) and with (red) detailed alignment, farrar\u2019s implementation (green) and SSEARCH (pink) each program was run on a single thread on a Linux machine with 2G MHz x86_64 AMD processors. two SW parameter settings are employed in the experiments. running time of different SW implementations for simulated genomic read alignment. Ion Torrent reads (236 bp) against E. coli (4.94 103 bp); and Illumina reads (100 bp) against T. gondii (6.08 107 bp); and (4) Illumina reads against human genome chromosome 1 (2.49 108 bp) the same SW parameter settings as the tests on the simulated data sets are used in the experiment. secondary short-read mapper Primary read mappers are often unable to map or properly align reads in structural variant (SV) regions. we developed a split-read aligner program, SCISSORS (https://github.com/wanpinglee/scissors) to map reads across structural variation event boundaries, rescuing reads not mapped. we used our SSW library to align read mates to the genomic regions indicated by the well-mapped mates\u2019 coordinates. the split-read mapping functionality has also been implemented in the TANGRAM SV detection tool (https://github.com/jiantao/Tangram) read-overlap graph generation. the SSW library is an application program interface that can be used to perform optimal protein or genome sequence alignment. the library returns the SW score, alignment location and traceback of the optimal alignment, and the alignment score and location of the suboptimal alignment. the library can also be used to validate alignments produced by heuristic read mappers. performance protein database search We compared SSW\u2019s performance to Farrar\u2019s accelerated SW and SSEARCH on a Linux machine with 2GHz x86 64 AMD processors. the optimal alignment scores for long DNA sequences given by SWPS3 are not consistent with others\u2019, we did not benchmark its running time here. implementations used the BLOSUM50 scoring matrix with gap open penalty -12 and extension penalty -2. we ran CUDASW++ 2.0 (on a GeForce GTX 480 graphics card with 1.5G memory) cores of match, mismatch, gap open and extension are 2, -1, -2, and -1 respectively. the command lines used for read alignments are shown in Table S2 in File S1. running time of different SW implementations for simulated genomic read alignment. the detailed genome and read information is described in Table S1 in File S1. results indicate that even while returning a full optimal alignment and one suboptimal score, our SSW algorithm is just as fast as Farrar\u2019s accelerated version. running time of aligning 1,000 real sequencing reads to various microorganism genomes and the human chromosome 1 are shown. our SSW algorithm is the fastest or equally fast to SSEARCH across the entire protein sequence length range we tested. 5 query proteins were searched against the whole Uni-Prot database and one quarter of the TrEMBL database. all SW implementations used the BLOSUM50 scoring matrix with gap open penalty -12 and extension penalty -2. the total running times in seconds of SSW, SSW-C, Farrar\u2019s, SSEARCH, and CUDASW++ 2.0 are 310.10, 597.35, 424.27, 270.94 and 66.75 respectively. this GPU SW is about four fold faster than the fasted CPU SW. all SW implementations were tested under two sets of SW parameters. scores of match, mismatch, gap open and extension are 2, -1, -2, and -1 respectively. results indicate that even while returning a full optimal alignment and one suboptimal score, our SSW algorithm is just as fast as Farrar\u2019s accelerated version. the log-scaled running time is shown on the y-axis for SSW without (blue) and with (red) detailed alignment, Farrar\u2019s implementation (green), SSEARCH (pink) and an ordinary SW implementation (black) all SW implementations were tested under two sets of SW parameters. scores of match, mismatch, gap open and extension are 2, -1, -2, and -1 respectively. we aligned three million Illumina 100 bp reads and one million 454 reads against the human genome. we used our SSW library to map reads across structural variation event boundaries (breakpoints), rescuing reads not mapped or inaccurately mapped by primary mapping approaches. read-overlap graphs were generated using 22,543 reads (70 bp long) from 191 africa samples in the 1000 Genomes Project dataset. the running time of the read-overlap graph generation program RZMBLR (https://github.com/ekg/rzmblr) embedded with an ordinary SW is about twice that embedded with our SSW library (973.02 seconds) we aligned three million Illumina 100 bp reads and one million 454 reads against the human genome. we used our SSW library to map reads across structural variation event boundaries (breakpoints), rescuing reads not mapped. read-overlap graph generation can be used to evaluate evidence for putative SV and large INDEL calls generated by assembly methods. we tested the effect of the SSW library in this application against a standard SW implementation (https://github/ekg/smithwaterman). a reversed SIMD SW and a banded SW generate the detailed alignment. we store the maximum score of each column in a \u201cmax\u201d array. the reversed SIMD SW locates the best alignment beginning position from the ending position by calculating a much smaller scoring matrix. the algorithm locates the optimal alignment ending position (the black cell with score 9) using the array of maximum scores. then traces back to the alignment start position (the black cell with score 2). the scores connected by solid arrows belong to the optimal alignment."}