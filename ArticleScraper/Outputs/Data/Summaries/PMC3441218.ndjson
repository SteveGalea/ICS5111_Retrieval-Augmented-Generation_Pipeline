{"summary": "Arapan-S is a whole-genome assembly program dedicated to handling small genomes. it provides only one contig (along with the reverse complement of this contig) in many cases. it provides only one contig (along with the reverse complement of this contig) the de bruijn graph has become the standard pillar of the so-called \u201cde novo\u201d assemblers. the de bruijn graph has become the standard pillar of the so-called \u201cde novo\u201d assemblers. a general assembler that is able to solve all cases will not be as effective and fast as a specific assembler that focuses on solving particular cases. ploidy can be a serious problem when dealing with plant genomes in which tetraploidy is common. the project acronym (Arapan) represents our primary goal to produce a software system that includes a set of open-source tools dedicated to solving and analyzing the whole genome assembly problem. the arapan-S assembler is very sensitive to the length of k of short reads, and because of its architecture our tool always tries to find one supercontig along with its reverse complement. apan-S assembler was very fast, used less memory and provided us with one supercontig along with its reverse complement in many cases. input data are given in Table 1, while Table 2, Table 3, Table 4 and Table 5 show the results. input data include seven Virus Genomes Species Accession number Number of reads Read average length (bp) the Expect-value was calculated by dividing Alignment scores by the corresponding Total lengths. the total length is the length of the obtained result, while Genome length is the genome\u2019s supposed length according to the EBI database. 7 30937 30937 30937 99.90 ABySS 1 30924 30924.00 30924 30924 99.85 SSAKE 9 27428 3047.56 3447 9868 88.57 Velvet 3 30951 10317.00 25461 25461 99.94 QSRA 8 29617 3702.125 - 11695 95.63 Minimus 1 31026 31026 31026 100.18 Mira 8 28803 ABySS 2 30943 15471.50 21535 21535 99.75 SSAKE 5 13925 2785.00 956 6100 44.89 Velvet 10 17800 1780.00 1090 3430 57.38 QSRA 8 7422 927.75 - 1323 23.93 Minimus 1 31019 31019 31019 100.00 Mira 10 34892 3489.2 6174 9191 112.48 Only contigs whose lengths only contigs whose lengths 400 were selected. each species has eight segments that constitute its genome. each species has eight segments that constitute its genome. the selected version of each assembler was the latest release. ABySS-1.2.7 [13], SSAKE 3.7 [7], Velvet 1.1.3 [9,10] and QSRA [15] were included for comparison. Arapan-S generated only one contig in all cases. SSAKE had the lowest genome coverage and more contigs most of the time. ABySS was again the second best assembler after Arapan-S. Arapan-S parameters Arapan-S was written in C/C++ language. the input data must represent each k-mer (i.e. de Bruijn sequence), along with its frequency in the same line, separated by a whitespace character. if the length of k is very short, the result of the assembly will not be significant. a minimum quality value cut-off of 20 (i.e. the accuracy of the base call was 99%) was set for most of the genomes. the low-quality end regions were trimmed at the 5\u2032-end and 3\u2032-end of every read. from CY006211.1 to CY006218.1 132 570 Influenza A Virus (A/Swine/Colorado/1/77/(H3N2)) Q288Y7 (EBI) 159 596 Influenza A Virus (A/Weiss/43/(H1N1)) The genome of each Influenza A Virus consists of eight segments while the others have only one long segment. 208 99.308% 0.0 The Total length is the length of the obtained result, while Genome length (EBI) is the genome\u2019s supposed length according to the EBI database. the Expect-value was calculated by dividing Alignment scores by the corresponding Total lengths. 100.00 Mira 5 33850 6770 20763 20763 109.28 Waterbuck Coronavirus US/OH-WD358-TC/1994 Arapan-S 1 30995 30995 100.00 ABySS 1 30944 30944.00 30944 30944 99.86 SSAKE 13 21780 1675.38 1063 5343 70.27 Velvet 8 12505 1563.12 967 2162 40.34 QSRA 5 4638 927 Influenza A Virus A/Memphis/1/71(H3N2) Arapan-S 8 12598 1574.75 1584 2311 94.03 ABySS 14 12897 921.21 1280 1801 96.27 SSAKE 1 555 555.00 - 555 4.14 Velvet 14 10774 769.57 789 1781 80.42 QSRA 17 12570 739.41 700 1828 93.83 Minimus 9 13 each species has eight segments that constitute its genome. comparison of Arapan-S with all assemblers onAntelope coronavirus US/OH1/2003. the current version of QSRA assembler is not able to deal with different read lengths. the most competitive assembler to Arapan-S was ABySS in Table 3. ABySS was also the second best assembler after Arapan-S. overlap-layout-consensus competitors Among the overlap-layout-consensus-based assemblers, Arapan-S was comparable to Minimus. minimus failed in one case, Influenza A Virus A/Memphis/1/71(H3N2) in which it produced nine contigs instead of eight. SSAKE failed to deal with small viral genomes. ABySS was again the second best assembler after Arapan-S. assembler succeeded in determining the eight segments of each genome. the frequency function is based on the assumption that nodes whose k-mers have longer, relative to shorter, lengths are more likely generated from trustworthy consecutive nodes. we have considered only the frequency function in the analysis presented here. in the case of non-uniform coverage of some areas in the genome, the frequency function may suffer from less accuracy. the raw data of small genomes can be easily found in the NCBI Trace Archive. the raw data are converted into a set of k-mers by kmerBuilder. the user can run Arapan-S assembler by providing it with the k-mer file. all complex bubbles are solved after a few iterations of the cleaning algorithm. the assembly algorithm uses the frequency values and lengths of k-mers in order to construct contigs. most de novo assemblers focus on solving large genomes. iftemp+\u201cG\u201d kmerListthen createArc( i, kmerList.IndexOf(\u201cA\u201d+ temp), i. if \u201cT\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cT\u201d+ temp), i. if \u201cC\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cC\u201d+ temp), i. a path collapsing procedure will return false if it does not collapse any path, otherwise, it returns true. the other procedures behave exactly as collapsePaths() does. bubble solving In genome assembly, a bubble appears where two sequences initially align, then diverge in the middle, and align again at the end. bubbles are caused by repeats or heterozygotes of diploid chromosomes [14] or created by errors or biological variants. a path is a chain of nodes in a graph. tips removal Tips generally result from errors at the end of reads. in Velvet, a tip is removed if it is shorter than 2 k (k is chosen for the k-mer) the result of the cleaning process will be similar to what is shown in Figure 5. a loop through all nodes of the graph must be implemented. the loop runs until no visited node can be found. the algorithm returns the connected component engendered from the node a. the assembly algorithm is a greedy function. it traverses the graph by selecting only the nodes whose frequency values are higher. the assembly algorithm is a greedy function. u := the index of the node which have the longest k-mer length. u := the index of the node which have the longest k-mer length. stringPath() algorithm is called the stringPath() algorithm. allPaths() 2. SetListC; //components list 3. SetListP; //paths list 4. Integeri; 5. //Step 1 6. Availability and requirements Arapan-S is open access and freely available. deBruijnGraphBuilder(HashTable kmerList, integerK) 2. integerN :=|kmerList|; //the size of kmerList 3. Stringtemp; 4. fori:=1 toNdo 5. begin 6. temp := kmerList[i][1..K1]; 7. //forward connection 8. iftemp+\u201cA\u201d kmerListthen createArc(i, kmerList.IndexOf(temp+\u201cA\u201d); 9. the de Bruijn graph is based on the exact matching of k-mers. some erroneous k-mers appear in the graph in different forms. the most common forms are the so-called \u201cTips, Bubbles and Chimeric connections\u201d. a path collapsing algorithm should be run immediately after constructing the graph. two nodes X and Y are merged if the node X has only one outgoing arc connected to the node Y that has only one incoming arc. their corresponding k-mers must be concatenated accordingly. the end node must not have any incoming edges other than those in the bubble. in Velvet, all bubbles will appear in the graph as shown in Figure 1. the result of the cleaning process will be similar to what is shown in Figure 5. a path is a chain of nodes in a graph. two nodes X and Y are merged if the node X has only one outgoing arc connected to the node Y that has only one incoming arc. their corresponding k-mers must be concatenated accordingly. in the graph, a tip is a node connected only on one end. in Velvet, a tip is removed if it is shorter than 2 k. after removing tips, new paths will appear again in the graph. connected components detection Once the graph is reduced, we start determining the connected component. the first case is the nature of the k-mers and their reverse complements. the second case is the sparseness of the graph, especially when the initial k-mer length is a bit longer. the idea of this algorithm is to traverse the graph from an arbitrary node a, mark it as a visited node and record its neighbors in the set X. the algorithm returns the connected component engendered from the node a. the assembly algorithm is a greedy function. it traverses the graph by selecting only the nodes whose frequency values are higher. k-mers are more likely to be free of sequencing errors. the bestNeighbor() function is the current node and the set of its in- or out-neighbors. each node could be connected to several neighbouring nodes. authors declare that they have no competing interests. authors\u2019 contributions MS and TS conceived the research."}