{"summary": "a short DNA sequence can contain less genetic information, while lots of bases may contain much more genetic information. a short DNA sequence can contain less genetic information, while lots of bases may contain much more genetic information. new method for calculating sequences different from other traditional methods. it holds not only statistical values but also structural information. we replace four nucleotides with tree structure presented in [9] and use mathematical tools to calculate complexity values of the sequences. a tree can transfer to a unique bracketed string by the following symbols. the tree can transfer to a unique bracketed string by the following symbols. the tree can be replaced by any word or omitted. rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object. rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object, using a set of rewriting rules or productions. the identity production s s is assumed. the symbols are called constants or terminals. we can also use rewriting rules to generate bracketed strings. in Figure 7, we show the rewriting rules for the bracketed string of each subtree. there are \u201cnulls\u201d in the rules, so we simply ignore the nulls. when tree grows up, the rewriting rules may generate identical rules. we define that rewriting rule R 1 and rewriting rule R 2 are homomorphic to each other if and only if they have the same structure. if rule R 1 and rule R 2 generate the same bracketed string, then they are homomorphic by definition. (5) We find that P, T L, T R, and T RR are homomorphic to each other. they generate the same bracketed string, [F][+F] but T RRR is not homomorphic to any of the other rules; its bracketed string is [F]. free grammar can be converted to automata. rewriting rules for the DNA tree can be converted to automata. [FT RLLL][+FT RLLR] T RLRL [F][+F] T RLRL [F][+FT RLRL] T RLRLR [F][+F] T RLRL [F][+FT RLRLR] T RLRRL [F][+F] T RLRRL [F][+F] T RLRRL [F][+F] T RRRL [FT RRRL][+F] T RRR the classification of the rules is listed in Table 2. The classification of the rules is listed in Table 2. Note that this section presents a new way to convert a context-sensitive grammar to a context-free one. a stack similarly structure represents the hierarchy of DNA tree, called bracketed string. the tree can transfer to a unique bracketed string by the following symbols, and it can transfer back to the original tree. tree can transfer to [F[+F][+F][+F][+F][+F][+F]] and [F[+F][+F]] respectively. we can simplify the bracketed string representations. first, our trees have only two subtrees; second, the \u201cF\u201d notation for the tree is trivial. rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object, using a set of rewriting rules or productions. in the next section, we will present how we use L-system to our DNA tree. in rewriting rules for DNA trees shown in Section 2.3, we write P LR for a tree with left and right subtrees. in this section, terminal nodes will be separated from trees, and we use \u201cnull\u201d to represent a terminal. this tree will have a bracketed string as follows: [[F][+F]]. we define that rewriting rule R 1 and rewriting rule R 2 are homomorphic to each other if and only if they have the same structure. if rule R 1 and rule R 2 generate exactly one bracketed string, then exactly one DNA tree. definition 3 \u2014 Isomorphism on level X in rewriting rules. rewriting rule R 1 and rewriting rule R 2 are isomorphic on depth X if they are homomorphic and their nonterminals are relatively isomorphic on depth X 1. we can classify all the rules into different subsets, and each subset has the same similarity relation. for example, we can give terminal rewriting rule a class, \u201cC 3 null\u201d and a rule link to two terminals. after performing classification, we obtain not only a new rewriting rule set but also a context-free grammar, which can be converted to automata. [FT LRLLL][+F] T LRLRL [F][+F] T LRLR [FT LRLRL][+FT LRRR] T LRRRL [F][+FT LRRLR] T LRRRL [F][+F] T LRRRL [F][+F] T RLRL [F][+FT RLLR] T RLRLR [F][+FT RLRLR] T RLRRL [F][+F] rules such as T RLLL [F][+F], T RLLL [F][+F] and T RLRLR [F][+F] are isomorphic on depth 1 and assigned to Class 4. the classification of the rules is listed in Table 2. C 4 C 2 (1) C 1 C 4 C 3 (1) C 1 C 2 C 2 (1) C 1 C 7 C 5 (1) C 1 C 5 C 2 (1) C 1 C 7 C 5 (1) C 1 C 5 C 2 (1) C 1 C 2 C 4 (1) C 1 C 8 C 8 C 8 C 1 C 3 C 1 C 3 C 1 C 1 C 3 C 1 C 1 C 3 C 1 C 1 C 8 C 6 (1) C 1 C 4 C 4 C 4 Class #2 (48) C 2 null (4) C 2 C the topological entropy K 0 of (context-free grammar) CFG can be evaluated by means of the following three procedures [16, 17]. the topological entropy is given by the radius of convergence R as K 0 = ln R. first, our productions are written in Chomsky-reduced form instead of Greibach form. second, DNA is finite sequence; it generates finite tree. after formulating the generating function V i(z), we intend to find the largest value of z, z max, at which V 1(z max) converges. we set R = z max, the radius of convergence of V 1(z) 2, V 2 ( z \u2032 ) = p = 1 n 2 n 2 p z \u2032 V a 2 p 1 ( z \u2032 ) q = 1 n i n i q = z \u2032 ( 4 V 4 ( z \u2032 ) q = 1 n n i n i q = 8 z \u2032 V 1 ( z \u2032 ) 2 + 2 ( z \u2032 ) 3 n 181 n 182 (5) C 1 C 4 C 4 Class #2 (n 2 = 1) n 21 n 211 n 212 (4) C 2 C 4 C 5 Class #3 (n 3 = 1) n 31 n 311 n 312 (4) C 3 C 5 C 4 Class #4 (n 4 = 1) n 51 n 511 n 512 (48) C 5 null Rearranging the previous equation for V 1(z\u2032), we obtain the formula V 1 ( p = 1 n i n i p z \u2032 V a i p 2 m 1 ( z \u2032 ) V a i p 2 m 1 ( z \u2032 ) q = 1 n i n i q, V i 0 ( z \u2032 ) = 1. results In 2011, Koslicki gave an efficient way to compute topological entropy of DNA sequence. we present a new method called structural complexity in previous sections. the results are very different from those obtained by the topological entropy method. our method can also calculate amino acid sequences. in Figure 13, we found that for larger fragment, the complexity curve will become smoothly because fragments for each data point contain more information. the simple sequence region is big enough that our fragment size still contains the same simple sequence. if we have many complexity values, we have the opportunity to restore the portion of the DNA. we can test data with topological entropy method and our method. if any object can be written as a sequence, and there exists tree representation with alphabet of sequence, we can compute the complexity of the object. these viruses have a significant impact and threat on the human world. in recent years, these viruses have a significant impact and threat on the human world. we test these viruses and prions listed in Table 4. this technique can be used in many important applications."}